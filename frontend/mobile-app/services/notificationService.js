import * as Notifications from 'expo-notifications';
import * as Device from 'expo-device';
import { Platform } from 'react-native';

// Configurar el comportamiento de las notificaciones
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: false,
  }),
});

class NotificationService {
  constructor() {
    this.expoPushToken = null;
    this.notificationListener = null;
    this.responseListener = null;
  }

  // Inicializar el servicio de notificaciones
  async initialize() {
    try {
      // Solicitar permisos
      const { status } = await this.requestPermissions();
      if (status !== 'granted') {
        console.log('Permisos de notificaci√≥n denegados');
        return false;
      }

      // Para notificaciones locales no necesitamos el token de push
      // Solo configuramos los listeners
      this.setupNotificationListeners();
      
      console.log('‚úÖ Servicio de notificaciones locales inicializado');
      return true;
    } catch (error) {
      console.error('Error inicializando notificaciones:', error);
      return false;
    }
  }

  // Solicitar permisos de notificaci√≥n
  async requestPermissions() {
    if (Platform.OS === 'android') {
      await Notifications.setNotificationChannelAsync('default', {
        name: 'default',
        importance: Notifications.AndroidImportance.MAX,
        vibrationPattern: [0, 250, 250, 250],
        lightColor: '#FF231F7C',
      });
    }

    const { status: existingStatus } = await Notifications.getPermissionsAsync();
    let finalStatus = existingStatus;
    
    if (existingStatus !== 'granted') {
      const { status } = await Notifications.requestPermissionsAsync();
      finalStatus = status;
    }
    
    return { status: finalStatus };
  }

  // Configurar listeners para notificaciones
  setupNotificationListeners() {
    // Listener para cuando se recibe una notificaci√≥n
    this.notificationListener = Notifications.addNotificationReceivedListener(notification => {
      console.log('Notificaci√≥n recibida:', notification);
    });

    // Listener para cuando el usuario toca una notificaci√≥n
    this.responseListener = Notifications.addNotificationResponseReceivedListener(response => {
      console.log('Respuesta a notificaci√≥n:', response);
      // Aqu√≠ puedes navegar a una pantalla espec√≠fica si es necesario
    });
  }

  // Programar notificaci√≥n para una tarea espec√≠fica
  async scheduleTaskNotification(task) {
    try {
      // Usar _id (MongoDB) o id seg√∫n lo que est√© disponible
      const taskId = task.id || task._id;
      console.log('üîç Programando notificaci√≥n para tarea:', { id: taskId, title: task.title, dueDate: task.dueDate });
      
      if (!task.dueDate) {
        console.log('Tarea sin fecha l√≠mite, no se programa notificaci√≥n');
        return null;
      }
      
      if (!taskId) {
        console.error('‚ùå Error: task.id y task._id son undefined o null:', task);
        return null;
      }

      const dueDate = new Date(task.dueDate);
      const now = new Date();
      
      // Calcular 24 horas antes de la fecha l√≠mite
      const notificationTime = new Date(dueDate.getTime() - (24 * 60 * 60 * 1000));
      let trigger = null;
      let body = '';
      const msRestantes = dueDate - now;
      const horasRestantes = msRestantes / (60 * 60 * 1000);
      const minutosRestantes = Math.floor((msRestantes % (60 * 60 * 1000)) / (60 * 1000));

      if (horasRestantes <= 24 && horasRestantes > 0) {
        // Solo notificar si faltan menos de 24h
        trigger = null; // Inmediato
        if (horasRestantes >= 1) {
          body = `"${task.title}" vence en ${Math.floor(horasRestantes)} hora(s) y ${minutosRestantes} minuto(s)`;
        } else {
          body = `"${task.title}" vence en ${minutosRestantes} minuto(s)`;
        }
        console.log(`Notificaci√≥n inmediata para tarea "${task.title}" (faltan menos de 24h)`);
        // NO cancelar notificaciones previas para trigger inmediato
      } else {
        // No notificar si faltan m√°s de 24h o ya venci√≥
        // Pero si en el futuro quieres programar una notificaci√≥n, aqu√≠ s√≠ cancelar√≠as la previa
        // await this.cancelTaskNotification(task.id);
        console.log('No se programa notificaci√≥n (faltan m√°s de 24h o ya venci√≥)');
        return null;
      }

      // Programar nueva notificaci√≥n
      const timestamp = Date.now();
      const identifier = `task_${taskId}_${timestamp}`;
      
      const notificationId = await Notifications.scheduleNotificationAsync({
        content: {
          title: '‚è∞ Tarea pr√≥xima a vencer',
          body,
          data: { 
            taskId: taskId,
            taskTitle: task.title,
            dueDate: task.dueDate,
            type: 'task_reminder',
            timestamp
          },
          sound: 'default',
        },
        trigger,
        identifier,
      });
      
      console.log(`‚úÖ Notificaci√≥n enviada con ID: ${identifier}`);
      return notificationId;
    } catch (error) {
      console.error('Error programando notificaci√≥n:', error);
      return null;
    }
  }

  // Cancelar notificaci√≥n de una tarea espec√≠fica
  async cancelTaskNotification(taskId) {
    try {
      const identifier = `task_${taskId}`;
      await Notifications.cancelScheduledNotificationAsync(identifier);
      console.log(`Notificaci√≥n cancelada para tarea ${taskId}`);
    } catch (error) {
      console.error('Error cancelando notificaci√≥n:', error);
    }
  }

  // Programar notificaciones para m√∫ltiples tareas
  async scheduleMultipleTaskNotifications(tasks) {
    const results = [];
    let delayMs = 0; // Delay acumulativo para notificaciones inmediatas
    
    for (const task of tasks) {
      if (!task.completed) { // Solo para tareas no completadas
        // Agregar delay para notificaciones inmediatas
        if (delayMs > 0) {
          await new Promise(resolve => setTimeout(resolve, delayMs));
        }
        
        const notificationId = await this.scheduleTaskNotification(task);
        if (notificationId) {
          const taskId = task.id || task._id;
          results.push({ taskId: taskId, notificationId });
          delayMs += 500; // 500ms de delay entre cada notificaci√≥n inmediata
        }
      }
    }
    return results;
  }

  // Cancelar todas las notificaciones de tareas
  async cancelAllTaskNotifications() {
    try {
      const scheduledNotifications = await Notifications.getAllScheduledNotificationsAsync();
      const taskNotifications = scheduledNotifications.filter(
        notification => notification.identifier.startsWith('task_')
      );
      
      for (const notification of taskNotifications) {
        await Notifications.cancelScheduledNotificationAsync(notification.identifier);
      }
      
      console.log(`${taskNotifications.length} notificaciones de tareas canceladas`);
    } catch (error) {
      console.error('Error cancelando todas las notificaciones:', error);
    }
  }

  // Obtener notificaciones programadas
  async getScheduledNotifications() {
    try {
      const notifications = await Notifications.getAllScheduledNotificationsAsync();
      return notifications.filter(notification => 
        notification.identifier.startsWith('task_')
      );
    } catch (error) {
      console.error('Error obteniendo notificaciones programadas:', error);
      return [];
    }
  }

  // Formatear hora para mostrar en la notificaci√≥n
  formatTime(date) {
    return date.toLocaleTimeString('es-ES', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  }

  // Enviar notificaci√≥n inmediata (para testing)
  async sendTestNotification() {
    try {
      await Notifications.scheduleNotificationAsync({
        content: {
          title: 'üß™ Notificaci√≥n de prueba',
          body: 'El sistema de notificaciones est√° funcionando correctamente',
          data: { type: 'test' },
        },
        trigger: null, // Enviar inmediatamente
      });
    } catch (error) {
      console.error('Error enviando notificaci√≥n de prueba:', error);
    }
  }

  // Limpiar listeners al destruir el servicio
  cleanup() {
    if (this.notificationListener) {
      Notifications.removeNotificationSubscription(this.notificationListener);
    }
    if (this.responseListener) {
      Notifications.removeNotificationSubscription(this.responseListener);
    }
  }
}

// Exportar instancia singleton
const notificationService = new NotificationService();
export default notificationService;
